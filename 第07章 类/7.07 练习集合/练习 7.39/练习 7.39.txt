如果我们为一个构造函数的全部形参都提供默认实参（包括为只接受一个形参的构造函数提供默认实参），则该构造函数实际上已构成默认构造函数。此时即使我们不提供任何实参，也可以找到可用的构造函数。
然而，若分别为两个构造函数的全部形参赋予默认实参，则这两个构造函数都具有了默认构造函数的作用。一旦我们不提供任何实参地创建类的对象，则编译器无法判断这两个（重载的）构造函数哪个更好，从而出现了二义性错误。