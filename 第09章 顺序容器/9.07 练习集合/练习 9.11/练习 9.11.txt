(1)vector<int> ivec1 ;
默认初始化，vector为空。调用size函数返回0，表明容器中还没有元素；调用capacity函数返回0，意味着尚未分配存储空间。这种初始化适用于元素个数和内容未知，需要在程序中动态添加的情况。
(2)vector<int> ivec2( ivec1 ) ;
ivec2初始化为ivec1的拷贝。ivec2必须与ivec1类型相同（即vector<int>类型），将具有与ivec1相同的容量和元素。
(3)vector<int> ivec3 = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ;
初始化为列表中元素的拷贝，列表中的元素类型必须完全满足ivec3的元素类型（不支持转化类型），在本例中必须是整数类，直接拷贝其值。这种初始化方式适合元素数量和内容事先可知的情况。
(4)vector<int> ivec4( ivec3.cbegin() + 2 , ivec3.cend() - 1 ) ;
ivec4内的元素初始化为两个迭代器指定范围内的元素的拷贝，范围内的元素类型必须与ivec4的元素类型相同或可以进行转换（迭代器来自不同容器也是允许的）。由于构造函数只是读取范围内的元素并进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并无区别。这种初始化方法特别适用于获取一个序列的子序列。
(5)vector<int> ivec5( 10 ) ;
默认值初始化。ivec5中将包含7个元素，每个元素进行默认值初始化，对于int也就是被赋值为0，因此ivec5包含了10个0.当程序运行初期元素大致数量可以预知，而元素的值可以动态获取，可采取这种初始化方式。
(6)vector<int> ivec6( 10 , 42 ) ;
指定值初始化。ivec6被初始化为10个值为42的int。
可以允许本节程序，获取更直观的认识。