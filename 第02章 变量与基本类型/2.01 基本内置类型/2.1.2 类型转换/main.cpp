// 本程序用于验证教材中2.1.2节内容的可靠性，并提供感性认知(当然，为了便于认知，在输出上优化了一点)
#include <iostream>
using namespace std;
int main() {
    /*
    bool b = 42 ;                         // 当我们把一个非bool类型的算数值赋给bool类型时，初始值为0则为false，否则结果为true(也可以直接赋给true或者false)
    cout << "b = " << b << endl;          // 但是要是输出它，只能够给出0或1
    int i = b ;                           // 当我们把一个bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1
    cout << "i = " << i << endl;
    i = 3.14 ;                            // 当我们把一个浮点数赋给整数类型时，会进行近似处理：结果值将仅保留整数部分！
    cout << "i = " << i << endl;
    double pi = i ;                       // 此处pi的值为3.0
    cout << "pi = " << pi + 0.1 << endl;
    unsigned char c = -1 ;               // 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，unsigned
    wcout << "c = " << c << endl;        // char可以表示0到255区间内的值，如果我们赋给了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，将
                                          // -1赋给8比特大小的unsigned char所得的结果是255（可以试试赋给负的浮点数，结果都是0）
    signed char c2 = 278 ;               // 当我们赋给带符号类型一个超出其表示范围的值时，结果是未定义的（此处不知为何是取模256后的数值），此时，程序可能继
    wcout << "c2 = " << c2 << endl;      // 续工作，可能崩溃，也可能生成垃圾数据，这都是需要避免的！
    */

    /*
    unsigned u = 10 ;
    int i = -42 ;
    cout << i + i << endl;               // 输出-84
    cout << u + i << endl;               // 输出4294967264（因为int有32位），因为首先-42先转化为了无符号数，再和u做运算
    u = 50 ;
    cout << u + i << endl;               // 输出8，和u做运算结果同样要取模
    */

    unsigned u1 = 42 , u2 = 10 ;        // 无符号数之间的运算结果永远不会出现负值，最多是取模后的非负值
    cout << u1 - u2 << endl;            // 输出32
    cout << u2 - u1 << endl;            // 输出4294967264

    return 0;
}
