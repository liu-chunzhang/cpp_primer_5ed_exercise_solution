一个比较合适的版本这样设计：令sum有两个模板参数，分别表示两个加法运算对象的类型（当然，它们得是相容类型），在设计尾置返回类型时，首先计算两个函数参数的和，然后对它们应用decltype来获取足以容纳它们的和的返回类型。函数代码为
template <typename T1,typename T2> auto sum( T1 a , T2 b ) ->decltype( a + b ) {
    return a + b ;
}
但是这个函数显然有致命缺点：它不能阻止计算结果正上溢和负上溢现象！
更为安全的方式是定义一个新的类型promote_t，用它来容纳一些小的类型，使它们能够在正上溢（负上溢）时转变为更大的类型。本题练习中定义了promote类，可以实现这一点，具体的内容可见和运行本节cbp文件。
