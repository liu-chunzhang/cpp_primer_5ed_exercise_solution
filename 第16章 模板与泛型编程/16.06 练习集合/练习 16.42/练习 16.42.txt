见教程P609中间，当我们将一个左值传递给f3的（右值引用）函数参数时，编译器推断模板参数为左值引用类型。所以
(a)T为int&，val的类型为int&。原因是，当实参为一个左值时，编译器推断为T为实参的左值引用类型，而非左值类型。而int& &&在引用折叠规则作用下被折叠为int&；
(b)T为const int&，val的类型为const int&。原因同(a)；
见教程P608中间，当一个函数参数是一个右值引用的时候，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通的左值引用函数实参的推断过程，推断出的模板参数类型是该右值实参的类型。所以
(c)T为int，val的类型是int&&。原因是，实参是一个右值，编译器就推断T为该右值的类型，因此val的类型就是右值类型的右值引用。